# Preprocessing parameters for experimental pipeline
strict_moderation: false
polis_id: "${runtime_params:polis_id, ${globals:build_polis_id}}" # small for tests, can be overridden via CLI
polis_url: "${runtime_params:polis_url, ${globals:build_polis_url}}" # Alternative to polis_id + base_url, e.g. "https://polis.example.com/{polis_id}" or "https://polis.example.com/report/{polis_id}"
min_votes_threshold: 7
base_url: null # Default to null, which will use https://pol.is in PolisAPIDataset
import_dir: null

visualization:
  flip_x: false
  flip_y: false

# NOTES:
#
#   - Any `${globals:*}` variables is set in the `globals.yml` file.
#   - A `null` value is converted to `None` in Python.
#   - When `random_state` set to null/None, a randomness generator will be used,
#     and pipelines will be non-deterministic.
#   - An `&anchor` is a named YAML reference, merged back in via `<<: *anchor`.
#   - An `input:*` value means that estimator will use that catalog item as it's input.

pipelines:
  # The original polis pipeline.
  mean_pca_bestkmeans: &polis_classic
    imputer:
      name: SimpleImputer
      strategy: mean

    reducer:
      name: PCA
      n_components: 2

    scaler:
      name: SparsityAwareScaler
      X_sparse: "input:masked_vote_matrix"

    filter:
      name: SampleMaskFilter
      mask: "input:participant_mask"

    clusterer:
      name: BestKMeans
      k_bounds: [2, 5]
      random_state: ${globals:random_state}

  mean_pca_bestkmeans_missing_transforms:
    <<: *polis_classic
    scaler:
      name: NoOpTransformer

    # # Breaks plots.
    # filter:
    #   name: NoOpTransformer

  # mean_pca_hdbscan:
  #   <<: *polis_classic
  #   clusterer:
  #     name: HDBSCAN

  # mean_pca_besthdbscanflat:
  #   <<: *polis_classic
  #   clusterer:
  #     name: BestHDBSCANFlat
  #     k_bounds: [2, 5]

  mean_pacmap_bestkmeans:
    imputer:
      name: SimpleImputer
      strategy: mean

    reducer:
      name: PaCMAP
      n_components: 2
      n_neighbors: null

    scaler:
      name: NoOpTransformer

    filter:
      name: SampleMaskFilter
      mask: "input:participant_mask"

    clusterer:
      name: BestKMeans
      k_bounds: [2, 5]
      random_state: ${globals:random_state}

  # mean_pacmap_besthdbscanflat:
  #   imputer:
  #     name: SimpleImputer
  #     strategy: mean

  #   reducer:
  #     name: PaCMAP
  #     n_components: 2
  #     n_neighbors: null
  #     random_state: ${globals:random_state}

  #   scaler:
  #     name: NoOpTransformer

  #   filter:
  #     name: SampleMaskFilter
  #     mask: "input:participant_mask"

  #   clusterer:
  #     name: BestHDBSCANFlat
  #     k_bounds: [2, 7]
  #     min_cluster_size: 20

  # mean_localmap_besthdbscanflat_eom: &mean_localmap_besthdbscanflat
  #   imputer:
  #     name: SimpleImputer
  #     strategy: mean

  #   reducer:
  #     name: LocalMAP
  #     n_components: 2
  #     n_neighbors: null
  #     random_state: ${globals:random_state}

  #   scaler:
  #     name: NoOpTransformer

  #   filter:
  #     name: SampleMaskFilter
  #     mask: "input:participant_mask"

  #   clusterer:
  #     name: BestHDBSCANFlat
  #     k_bounds: [2, 7]
  #     min_cluster_size: 20
  #     cluster_selection_method: "eom"

  # mean_localmap_besthdbscanflat_leaf:
  #   <<: *mean_localmap_besthdbscanflat
  #   clusterer:
  #     name: BestHDBSCANFlat
  #     k_bounds: [2, 7]
  #     min_cluster_size: 20
  #     cluster_selection_method: "leaf"

  mean_localmap_bestkmeans:
    imputer:
      name: SimpleImputer
      strategy: mean

    reducer:
      name: LocalMAP
      n_components: 2
      n_neighbors: null
      random_state: ${globals:random_state}

    scaler:
      name: NoOpTransformer

    filter:
      name: SampleMaskFilter
      mask: "input:participant_mask"

    clusterer:
      name: BestKMeans
      k_bounds: [2, 7]
      random_state: ${globals:random_state}

  # knn5d_pacmap_besthdbscanflat: &knn5d_pacmap_besthdbscanflat
  #   imputer:
  #     name: KNNImputer
  #     n_neighbors: 5
  #     weights: distance

  #   reducer:
  #     name: PaCMAP
  #     n_components: 2
  #     n_neighbors: null
  #     random_state: ${globals:random_state}

  #   scaler:
  #     name: NoOpTransformer

  #   filter:
  #     name: SampleMaskFilter
  #     mask: "input:participant_mask"

  #   clusterer:
  #     name: BestHDBSCANFlat
  #     k_bounds: [2, 7]

  # knn5d_localmap_besthdbscanflat:
  #   <<: *knn5d_pacmap_besthdbscanflat
  #   reducer:
  #     name: LocalMAP
  #     n_components: 2
  #     n_neighbors: null
  #     random_state: ${globals:random_state}

  # knn5d_pca_besthdbscanflat:
  #   <<: *knn5d_pacmap_besthdbscanflat
  #   reducer:
  #     name: PCA
  #     n_components: 2
  #     random_state: ${globals:random_state}

  knn5d_pacmap_bestkmeans: &knn5d_pacmap_bestkmeans
    imputer:
      name: KNNImputer
      n_neighbors: 5
      weights: distance

    reducer: &pacmap_reducer
      name: PaCMAP
      n_components: 2
      n_neighbors: null
      random_state: ${globals:random_state}

    scaler:
      name: NoOpTransformer

    filter:
      name: SampleMaskFilter
      mask: "input:participant_mask"

    clusterer:
      name: BestKMeans
      k_bounds: [2, 5]
      random_state: ${globals:random_state}

  knn5d_localmap_bestkmeans:
    <<: *knn5d_pacmap_bestkmeans
    reducer:
      <<: *pacmap_reducer
      name: LocalMAP
      random_state: ${globals:random_state}

  knn5d_pca_bestkmeans:
    <<: *knn5d_pacmap_bestkmeans
    reducer:
      name: PCA
      n_components: 2
      random_state: ${globals:random_state}

  mean_umap_bestkmeans:
    <<: *knn5d_pacmap_bestkmeans
    imputer:
      name: SimpleImputer
      strategy: mean

    reducer:
      name: UMAP
      n_components: 2
      n_neighbors: 15
      random_state: ${globals:random_state}

  knn5d_umap_bestkmeans:
    <<: *knn5d_pacmap_bestkmeans
    reducer:
      name: UMAP
      n_components: 2
      n_neighbors: 15
      random_state: ${globals:random_state}

# Branching pipeline configuration
# This creates a single DAG where preprocessing runs once, each imputer runs once,
# each reducer runs once per imputer, and then multiple clusterers run on each
# imputer-reducer combination's output
branching_pipeline:
  # Control whether to generate plot images (false by default to save time)
  generate_plots: false

  shared_stages:
    filter:
      estimator: SampleMaskFilter
      mask: "input:participant_mask"

  imputers:
    - name: mean
      estimator: SimpleImputer
      strategy: mean
    - name: zero
      estimator: SimpleImputer
      strategy: constant
      fill_value: 0
    - name: median
      estimator: SimpleImputer
      strategy: median
    - name: mode
      estimator: SimpleImputer
      strategy: most_frequent
      _include_in_full_matrix: false  # Exclude from full matrix but available for variants
    - name: knn5d
      estimator: KNNImputer
      n_neighbors: 5
      weights: distance
    - name: knn5u
      estimator: KNNImputer
      n_neighbors: 5
      weights: uniform
    - name: knn10d
      estimator: KNNImputer
      n_neighbors: 10
      weights: distance
    - name: knn10u
      estimator: KNNImputer
      n_neighbors: 10
      weights: uniform
    - name: noop
      estimator: NoOpTransformer
      _include_in_full_matrix: false  # Special imputer for raw data analysis

  reducers:
    - name: pca
      estimator: PCA
      n_components: 2
      random_state: ${globals:random_state}
      _scaler:
        estimator: SparsityAwareScaler
        X_sparse: "input:masked_vote_matrix"
    - name: pca_no_scale
      estimator: PCA
      n_components: 2
      random_state: ${globals:random_state}
      _include_in_full_matrix: false # Just to see effects of skipping SparsityAwareScaler
      _scaler:
        estimator: NoOpTransformer
    - name: pacmap
      estimator: PaCMAP
      n_components: 2
      n_neighbors: null
      random_state: ${globals:random_state}
      _scaler:
        estimator: NoOpTransformer
    - name: pacmap_masked
      estimator: PaCMAPWithMaskedDistance
      n_components: 2
      n_neighbors: null
      random_state: ${globals:random_state}
      _include_in_full_matrix: false  # Special variant for raw data analysis
      _scaler:
        estimator: NoOpTransformer
    - name: localmap
      estimator: LocalMAP
      n_components: 2
      n_neighbors: null
      random_state: ${globals:random_state}
      _scaler:
        estimator: NoOpTransformer
    - name: umap
      estimator: UMAP
      n_components: 2
      n_neighbors: 15
      random_state: ${globals:random_state}
      _scaler:
        estimator: NoOpTransformer

  clusterers:
    - name: bestkmeans
      estimator: BestKMeans
      k_bounds: [2, 5]
      random_state: ${globals:random_state}
    - name: besthdbscan
      estimator: BestHDBSCANFlat
      # cluster_selection_method: leaf # Uncommenting gets around occasional error in HDBSCAN_flat
      k_bounds: [2, 7]
      random_state: ${globals:random_state}
    - name: hdbscan_eom
      estimator: HDBSCAN
      cluster_selection_method: eom
    - name: hdbscan_leaf
      estimator: HDBSCAN
      cluster_selection_method: leaf

  # Variants allow you to define named subsets of the pipeline matrix
  # Each variant can override or constrain parts of the matrix
  variants:
    full_matrix:
      description: "Full matrix expansion (all combinations with include_in_full_matrix=true)"
      active: true
      # When no specific imputers/reducers/clusterers are defined, uses all from global lists
      # that have include_in_full_matrix=true (or unspecified, which defaults to true)

    zero_pacmap_masked_bestkmeans:
      name: zero_pacmap_masked_bestkmeans
      active: true
      imputer: noop           # zero imputation happens within the custom PaCMAP estimator
      reducer: pacmap_masked  # PaCMAP with masked distance
      clusterer: bestkmeans   # simple clustering

    mean_pca_bestkmeans_missing_transforms:
      name: mean_pca_bestkmeans_missing_transforms
      active: true
      imputer: mean           # SimpleImputer with mean strategy
      reducer: pca_no_scale   # PCA without scaling (NoOpTransformer)
      clusterer: bestkmeans   # BestKMeans clustering